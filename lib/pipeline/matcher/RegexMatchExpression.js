"use strict";
var LeafMatchExpression = require('./LeafMatchExpression');


	// Autogenerated by cport.py on 2013-09-17 14:37
var RegexMatchExpression = module.exports = function RegexMatchExpression(){
	base.call(this);
	this._matchType = 'REGEX';
}, klass = RegexMatchExpression, base =  LeafMatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});

	// File: expression_leaf.h lines: 160-160
klass.MaxPatternSize = 32764;

	// File: expression_leaf.h lines: 184-184
proto._flags = undefined;

	// File: expression_leaf.h lines: 185-185
proto._re = undefined;

	// File: expression_leaf.h lines: 183-183
proto._regex = undefined;

/**
 *
 * Writes a debug string for this object
 * @method debugString
 * @param level
 *
 */
proto.debugString = function debugString(level) {
	// File: expression_leaf.cpp lines: 225-234
	return this._debugAddSpace( level ) + this.path() + " regex /" + this._regex + "/" + this._flags + (this.getTag() ? ' ' + this.getTag().debugString : '') + "\n";
};

/**
 *
 * checks if this expression is == to the other
 * @method equivalent
 * @param other
 *
 */
proto.equivalent = function equivalent(other) {
	// File: expression_leaf.cpp lines: 177-185
	return other._matchType == 'REGEX' && this.path() == other.path() && this._regex == other._regex && this._flags == other._flags;
};

/**
 *
 * Return the _flags property
 * @method getFlags
 *
 */
proto.getFlags = function getFlags(){
	// File: expression_leaf.h lines: 180-179
	return this._flags;
};

/**
 *
 * Return the _regex property
 * @method getString
 * @param
 *
 */
proto.getString = function getString(){
	// File: expression_leaf.h lines: 179-178
	return this._regex;
};

/**
 *
 * Initialize the necessary items
 * @method init
 * @param path
 * @param type
 *
 */
proto.init = function init(path,regex,flags) {
	// File: expression_leaf.cpp lines: 196-205
	if(regex.toString().length > klass.MaxPatternSize){
		return {'code':'BAD_VALUE', 'desc':'Regular Expression too long.'};
	}

	this._regex = regex;
	this._flags = flags;
	this._re = new RegExp(regex,flags);
	return this.initPath( path );
};

/**
 *
 * Check if the input element matches
 * @method matchesSingleElement
 * @param e
 *
 */

proto.matchesSingleElement = function matchesSingleElement(e) {
// File: expression_leaf.cpp lines: 208-222
	if(e instanceof RegExp){
		return e.toString() === this._re.toString();
	}
	return e && (e.match) && e.match(this._re);
	// No support for SYMBOLS currently
};

/**
 *
 * clone this instance to a new one
 * @method shallowClone
 *
 */
proto.shallowClone = function shallowClone(){
	// File: expression_leaf.h lines: 167-170
	var e = new RegexMatchExpression();
	e.init( this.path(), this._regex, this._flags );
	return e;
};

